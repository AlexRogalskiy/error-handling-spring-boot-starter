= Error Handling Spring Boot Starter
Wim Deblauwe
:doctype: book
:idprefix:
:idseparator: -
:toc: left
:toclevels: 4
:tabsize: 4
:numbered:
:sectanchors:
:sectnums:
:hide-uri-scheme:
:docinfo: shared,private

This documentation is for version {project-version}.

== Goal

The goal of the project is to make it easy to have proper error responses for REST APIs build with Spring Boot.
Just like Spring Boot itself it takes an opinionated approach to how the response body should look like in the case of an error.

== Getting started

=== Add the library to your project

The library is available on https://mvnrepository.com/artifact/io.github.wimdeblauwe/error-handling-spring-boot-starter[Maven Central], so it is easy to add the dependency to your project.

[source,xml,indent=0,role="primary"]
.Maven
----
<dependency>
    <groupId>io.github.wimdeblauwe</groupId>
    <artifactId>error-handling-spring-boot-starter</artifactId>
    <version>LATEST_VERSION_HERE</version>
</dependency>
----

[source,indent=0,role="secondary"]
.Gradle
----
compile 'io.github.wimdeblauwe:error-handling-spring-boot-starter:LATEST_VERSION_HERE'
----

NOTE: This library is indented to be used with a https://spring.io/projects/spring-boot[Spring Boot] project.
It will not work outside of a Spring Boot project.

=== Usage

==== Default `Exception` handling

By adding the library on the classpath, it will become active.
It registers an `@ControllerAdvice` bean in the context that will act if an exception is thrown from a `@RestController` method.

Suppose there is a custom Exception like this:

[source,java]
----
package com.company.application.user;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(UserId userId) {
        super("Could not find user with id " + userId);
    }
}
----

When this `UserNotFoundException` is thrown from a controller method, the library will return a JSON response like this:

[source,json]
----
{
  "code": "com.company.application.user.UserNotFoundException",
  "message": "Could not find user with id 123"
}
----

The HTTP status code will be _500 Internal Server Error_.

Next to this quite simple default behaviour, there is special handling for some of the common Spring exceptions and there is an extensive amount of <<Configuration,customization options>> that should make this library a good fit for all of your error handling for REST controllers.

==== Validation exception handling

For some exceptions like https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/MethodArgumentNotValidException.html[`MethodArgumentNotValidException`], https://docs.oracle.com/javaee/7/api/javax/validation/ConstraintViolationException.html[`ConstraintViolationException`],... there is special handling and extra information is returned in the response.

For example, suppose you have this class:

[source,java]
----
public class ExampleRequestBody {
    @Size(min = 10)
    private String name;
    @NotBlank
    private String favoriteMovie;

    // getters and setters
}
----

Which is used as a request body in a controller like this:

[source,java]
----
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;

@RestController
@RequestMapping("/example")
public class MyExampleController {

    @PostMapping
    public MyResponse doSomething(@Valid @RequestBody ExampleRequestBody requestBody ) {
        // ...
    }
}
----

When sending a JSON request body like this:

[source,json]
----
{
    "name": "",
    "favoriteMovie": null
}
----

The validation fails, and the following JSON response will be returned:

[source,json]
----
{
  "code": "VALIDATION_FAILED",
  "message": "Validation failed for object='exampleRequestBody'. Error count: 2",
  "fieldErrors": [
    {
      "code": "INVALID_SIZE",
      "property": "name",
      "message": "size must be between 10 and 2147483647",
      "rejectedValue": ""
    },
    {
      "code": "REQUIRED_NOT_BLANK",
      "property": "favoriteMovie",
      "message": "must not be blank",
      "rejectedValue": null
    }
  ]
}
----

NOTE: If there are validation errors on the class level, they will be added in the response as `globalErrors`.

==== With `@SpringBootTest`

There is nothing special to configure for unit tests that use `@SpringBootTest`.
The library is automatically active when it is on the classpath.

==== With `@WebMvcTest`

There is nothing special to configure for unit tests that use `@WebMvcTest`.
The library is automatically active when it is on the classpath.

== Configuration

=== HTTP response status

==== Set HTTP response status via `@ResponseStatus`

The library uses _500 Internal Server Error_ as HTTP response code by default, just like Spring Boot does.

To set a specific status code, you can use `@ResponseStatus`, which is also standard Spring Boot behaviour.
The library will honor what is set there.

Example:

[source,java]
----
package com.company.application.user;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND) //<.>
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(UserId userId) {
        super("Could not find user with id " + userId);
    }
}
----
<.> Specify the HTTP response status via a class level annotation.

==== Set HTTP response status via properties

Use the `error.handling.http-statuses` property to set the HTTP response status without adding an annotation to the sources of the Exception class itself.
This is mostly useful if you don't control the sources of the Exception.

For example:

[source,properties]
----
error.handling.http-statuses.java.lang.IllegalArgumentException=bad_request
----

By setting this, any `IllegalArgumentException` that happens will have a _400 Bad Request_ response code.
The values are the enum values from https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.html[`org.springframework.http.HttpStatus`].

=== Error codes

==== Error code style

By default, the full qualified name of the `Exception` class is used as the `code` in the response.
If you like to use ALL_CAPS style for the codes, then specify this property:

[source,properties]
----
error.handling.default-error-code-strategy=all_caps_conversion
----

This style will truncate `Exception` from the class name and convert the camel case into upper case snake case.

For a class called `UserNotFoundException`, this will result in the following JSON:

[source,json]
----
{
  "code": "USER_NOT_FOUND",
  "message": "Could not find user with id 123"
}
----

==== General override of error codes

If the default <<Error code style>> is not enough for what you need, you can set a code via the properties by using the full qualified name under the `error.handling.codes` key:

[source,properties]
----
error.handling.codes.java.lang.IllegalArgumentException=ILLEGAL_ARGUMENT
----

Result:

[source,json]
----
{
  "code": "ILLEGAL_ARGUMENT",
  "message": "argument was not as expected"
}
----

This is mostly useful for `Exception` types that are not under your own control (E.g. they are coming from a library that you use).
If you do have control, it is probably easier to use <<Per class override of error code>>.

==== Per class override of error code

By adding the `@ResponseErrorCode` annotation as a class level annotation, it is possible to define the `code` that the response will be using.

Example:

[source,java]
----
package com.company.application.user;

import io.github.wimdeblauwe.errorhandlingspringbootstarter.ResponseErrorCode;

@ResponseErrorCode("COULD_NOT_FIND_USER")
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(UserId userId) {
        super("Could not find user with id " + userId);
    }
}
----

This results in this response:

[source,json]
----
{
  "code": "COULD_NOT_FIND_USER",
  "message": "Could not find user with id 123"
}
----

==== General override of validation error codes

The library has codes defined for all https://docs.oracle.com/javaee/7/api/javax/validation/constraints/package-summary.html[javax.validation.constraints] annotations.
It is possible to override those via the `application.properties`.

The default `code` for `@Size` is `INVALID_SIZE`, but if you want to change this to `SIZE_REQUIREMENT_NOT_MET`, then define the following property:

[source,properties]
----
error.handling.codes.Size=SIZE_REQUIREMENT_NOT_MET
----

If there is now a validation error for `@Size`, then the response body will be:

[source,json]
----
{
  "code": "VALIDATION_FAILED",
  "message": "Validation failed for object='exampleRequestBody'. Error count: 1",
  "fieldErrors": [
    {
      "code": "SIZE_REQUIREMENT_NOT_MET", // <.>
      "property": "name",
      "message": "size must be between 10 and 2147483647",
      "rejectedValue": ""
    }
  ]
}
----
<.> Custom code used for the field error

==== Field specific override of validation error codes

It is possible to configure a specific error code that only will be used for a combination of a field with a validation annotation.

Suppose you add a regex to validate password rules:

[source,java]
----
public class CreateUserRequestBody {
    @Pattern(".*{8}")
    private String password;

    // getters and setters
}
----

By default, this error is in the response:

[source,json]
----
{
  "code": "VALIDATION_FAILED",
  "message": "Validation failed for object='createUserRequestBody'. Error count: 1",
  "fieldErrors": [
    {
      "code": "REGEX_PATTERN_VALIDATION_FAILED",
      "property": "password",
      "message": "must match \".*{8}\"",
      "rejectedValue": ""
    }
  ]
}
----

If we would use `error.handling.codes.Pattern` for the override, then all `@Pattern` annotations in the whole application would use a different code.
If we want to only override this for fields that are named `password`, we can use:

[source,properties]
----
error.handling.codes.password.Pattern=PASSWORD_COMPLEXITY_REQUIREMENTS_NOT_MET
----

This results in:

[source,json]
----
{
  "code": "VALIDATION_FAILED",
  "message": "Validation failed for object='createUserRequestBody'. Error count: 1",
  "fieldErrors": [
    {
      "code": "PASSWORD_COMPLEXITY_REQUIREMENTS_NOT_MET",
      "property": "password",
      "message": "must match \".*{8}\"",
      "rejectedValue": ""
    }
  ]
}
----

=== Error messages

==== Default behaviour

The library will output the `message` property of the Exception into the `message` JSON field by default.

For example:

[source,java]
----
package com.company.application.user;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(UserId userId) {
        super("Could not find user with id " + userId);
    }
}
----

The response JSON:

[source,json]
----
{
  "code": "com.company.application.user.UserNotFoundException",
  "message": "Could not find user with id 123" //<.>
}
----
<.> The output uses the `message` of the Exception by default.

==== General override of error messages

By using `error.handling.messages` property, it is possible to globally set an error message for a certain exception.
This is most useful for the validation messages.

Suppose you have this defined:

[source,properties]
----
error.handling.messages.NotBlank=The property should not be blank
----

Then the `message` in the output is this:

[source,json]
----
{
  "code": "VALIDATION_FAILED",
  "message": "Validation failed for object='exampleRequestBody'. Error count: 1",
  "fieldErrors": [
    {
      "code": "REQUIRED_NOT_BLANK",
      "property": "name",
      "message": "The property should not be blank",//<.>
      "rejectedValue": ""
    }
  ]
}
----
<.> Custom message used for the field error

So you start with `error.handling.messages` and suffix with the name of the validation annotation used (`@NotBlank` in the above example).

==== Field specific override of error messages

It is possible to configure a specific error message that only will be used for a combination of a field with a validation annotation.

Suppose you add a regex to validate password rules:

[source,java]
----
public class CreateUserRequestBody {
    @Pattern(".*{8}")
    private String password;

    // getters and setters
}
----

By default, this error is in the response:

[source,json]
----
{
  "code": "VALIDATION_FAILED",
  "message": "Validation failed for object='createUserRequestBody'. Error count: 1",
  "fieldErrors": [
    {
      "code": "REGEX_PATTERN_VALIDATION_FAILED",
      "property": "password",
      "message": "must match \".*{8}\"",
      "rejectedValue": ""
    }
  ]
}
----

If we would use `error.handling.messages.Pattern` for the override, then all `@Pattern` annotations in the whole application would use a different message.
If we want to only override this for fields that are named `password`, we can use:

[source,properties]
----
error.handling.messages.password.Pattern=The password complexity rules are not met. A password must be 8 characters minimum.
----

This results in:

[source,json]
----
{
  "code": "VALIDATION_FAILED",
  "message": "Validation failed for object='createUserRequestBody'. Error count: 1",
  "fieldErrors": [
    {
      "code": "REGEX_PATTERN_VALIDATION_FAILED",
      "property": "password",
      "message": "The password complexity rules are not met. A password must be 8 characters minimum.", //<.>
      "rejectedValue": ""
    }
  ]
}
----
<.> Custom error message used in the response

=== Exception handlers

==== Validation

There are 2 cases that this library will create specific JSON responses when validation errors occur:

. When using `@Valid` in the parameter of a controller method.
For example:
+
[source,java]
----
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;

@RestController
@RequestMapping("/example")
public class MyExampleController {

    @PostMapping
    public MyResponse doSomething(@Valid @RequestBody ExampleRequestBody requestBody ) {
        // ...
    }
}
----

. When using validation annotations on Spring components that are themselves annotated with https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/annotation/Validated.html[`@Validated`].
For example:
+
[source,java]
----
import org.springframework.stereotype.Service;
import org.springframework.validation.annotation.Validated;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;

@Service
@Validated
public static class TestService {
    void doSomething(@Valid TestRequestBody requestBody,
                     @NotNull String extraArg) {

    }
}
----

In both cases, the response JSON will be similar to this:

[source,json]
----
{
  "code": "VALIDATION_FAILED",
  "message": "Validation failed for object='exampleRequestBody'. Error count: 4",
  "fieldErrors": [
    {
      "code": "INVALID_SIZE",
      "property": "name",
      "message": "size must be between 10 and 2147483647",
      "rejectedValue": ""
    },
    {
      "code": "REQUIRED_NOT_BLANK",
      "property": "favoriteMovie",
      "message": "must not be blank",
      "rejectedValue": null
    }
  ],
  "globalErrors": [
    {
      "code": "ValidCustomer",
      "message": "Invalid customer"
    },
    {
      "code": "ValidCustomer",
      "message": "UserAlreadyExists"
    }
  ]
}
----

Breakdown:

* The `code` is always `VALIDATION_FAILED` (unless there was an override defined)
* The `message` indicates what object failed the validation and also indicates the amount of validation errors.
* The `fieldErrors` array contains all field-level validation problems.
It shows the name of the property that failed the validation and the value that was received in the request.
* The `globalErrors` array contains the class-level validation problems.
+
The `code` and `message` used for `globalErrors` is based on the annotation that was used for validation:
+
[source,java]
----
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CustomerValidator.class)
public @interface ValidCustomer {
    String message() default "Invalid customer";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
----
+
As well as the template that is used in the validator itself:
+
[source,java]
----
public class CustomerValidator implements ConstraintValidator<ValidCustomer, CreateCustomerFormData> {
    @Override
    public boolean isValid(CreateCustomerFormData formData, ConstraintValidatorContext context) {

        if(...) {
            context.buildConstraintViolationWithTemplate("UserAlreadyExists").addConstraintViolation();
        }
    }
}
----

[NOTE]
====
If you want to change the message for the global errors, the default Spring mechanismn to do see keeps working.

So use `{}` to indicate that Spring should search the `messages.properties` file:

[source,java]
----
context.buildConstraintViolationWithTemplate("{UserAlreadyExists}").addConstraintViolation();
----

Now add the translation to the `messages.properties`:

[source,properties]
----
UserAlreadyExists=The user already exists
----

This results in:

[source,json]
----
{
  "code": "VALIDATION_FAILED",
  "message": "Validation failed for object='exampleRequestBody'. Error count: 2",
  "globalErrors": [
    {
      "code": "INVALID_CUSTOMER",
      "message": "Invalid customer"
    },
    {
      "code": "INVALID_CUSTOMER",
      "message": "The user already exists"
    }
  ]
}
----

====

==== Unreadable HTTP message

If a controller receives a message that it cannot read, because the JSON is invalid for example, then a `HttpMessageNotReadableException` is thrown.
When this happens, the library will return something like the following response:

[source,json]
----
{
  "code": "MESSAGE_NOT_READABLE",
  "message": "JSON parse error: Unexpected character ('i' (code 105)): was expecting double-quote to start field name; nested exception is com.fasterxml.jackson.core.JsonParseException: Unexpected character ('i' (code 105)): was expecting double-quote to start field name\n at [Source: (PushbackInputStream); line: 1, column: 3]"
}
----

==== Type conversion exceptions

Type conversion exceptions like `MethodArgumentTypeMismatchException` and `TypeMismatchException` will have some extra info about the class that was expected and the value that was rejected:

[source,json]
----
{
  "code": "ARGUMENT_TYPE_MISMATCH",
  "message": "Failed to convert value of type 'java.lang.String' to required type 'com.example.user.UserId'; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [@org.springframework.web.bind.annotation.PathVariable com.example.user.UserId] for value 'fake_UUID'; nested exception is java.lang.IllegalArgumentException: Invalid UUID string: fake_UUID",
  "expectedType": "com.example.user.UserId",
  "property": "userId",
  "rejectedValue": "fake_UUID"
}
----

==== Optimistic locking exceptions

When an `org.springframework.orm.ObjectOptimisticLockingFailureException` is thrown, the resulting response will be something like:

[source,json]
----
{
  "code": "OPTIMISTIC_LOCKING_ERROR",
  "message": "Object of class [com.example.user.User] with identifier [87518c6b-1ba7-4757-a5d9-46e84c539f43]: optimistic locking failed",
  "identifier": "87518c6b-1ba7-4757-a5d9-46e84c539f43",
  "persistentClassName": "com.example.user.User"
}
----

==== Spring Security exceptions

If Spring Security is on the classpath, then those exceptions will be handled.
They will just have a `code` and a `message`.

For example:

[source,json]
----
{
  "code": "ACCESS_DENIED",
  "message": "Access is denied"
}
----

The full list of Exception types that are handled:

* AccessDeniedException
* AccountExpiredException
* AuthenticationCredentialsNotFoundException
* AuthenticationServiceException
* BadCredentialsException
* UsernameNotFoundException
* InsufficientAuthenticationException
* LockedException
* DisabledException

=== Adding extra properties in the response

It is possible add extra properties in the JSON response by using the `@ErrorResponseProperty` annotation in your custom Exception class.

==== Via method annotation

This example annotates the `getUserId()` method with `@ResponseErrorProperty` so that the return value of the method is added to the JSON response:

[source,java]
----
@ResponseStatus(HttpStatus.NOT_FOUND)
@ResponseErrorCode("USER_NOT_FOUND")
public class UserNotFoundException extends RuntimeException {

    private final UserId userId;

    public UserNotFoundException(UserId userId) {
        super(String.format("Could not find user with id %s", userId));
        this.userId = userId;
    }

    @ResponseErrorProperty // <.>
    public String getUserId() {
        return userId.getValue();
    }
}
----
<.> Add the result of this method as an extra property in the response

The resulting response:

[source,json]
----
{
  "code": "USER_NOT_FOUND",
  "message": "Could not find user with id UserId{id=8c7fb13c-0924-47d4-821a-36f73558c898}",
  "userId": "8c7fb13c-0924-47d4-821a-36f73558c898"
}
----

==== Via field annotation

This example annotates the `userId` field with `@ResponseErrorProperty` so that the value of the field is added to the JSON response:

[source,java]
----
@ResponseStatus(HttpStatus.NOT_FOUND)
@ResponseErrorCode("USER_NOT_FOUND")
public class UserNotFoundException extends RuntimeException {

    @ResponseErrorProperty // <.>
    private final UserId userId;

    public UserNotFoundException(UserId userId) {
        super(String.format("Could not find user with id %s", userId));
        this.userId = userId;
    }
}
----
<.> Add the result of this method as an extra property in the response

The resulting response:

[source,json]
----
{
  "code": "USER_NOT_FOUND",
  "message": "Could not find user with id UserId{id=8c7fb13c-0924-47d4-821a-36f73558c898}",
  "userId": "8c7fb13c-0924-47d4-821a-36f73558c898"
}
----

NOTE: The annotated field can be `public` or `private`.

==== Overriding the property name

It is also possible to override the property name that will be used in the response by using the `value` argument of the annotation.

[source,java]
----
@ResponseStatus(HttpStatus.NOT_FOUND)
@ResponseErrorCode("USER_NOT_FOUND")
public class UserNotFoundException extends RuntimeException {

    ...

    @ResponseErrorProperty("id")
    public String getUserId() {
        return userId.asString();
    }
}
----

The resulting response:

[source,json]
----
{
  "code": "USER_NOT_FOUND",
  "message": "Could not find user with id UserId{id=8c7fb13c-0924-47d4-821a-36f73558c898}",
  "id": "8c7fb13c-0924-47d4-821a-36f73558c898"
}
----

==== Null handling

If a property or method that is annotated with `@ResponseErrorProperty` returns `null`, then the JSON output will not contain the property by default.
If this is desirable, then use the `includeIfNull` property on the annotation to change this behaviour:

[source,java]
----
@ResponseStatus(HttpStatus.NOT_FOUND)
@ResponseErrorCode("USER_NOT_FOUND")
public class UserNotFoundException extends RuntimeException {

    private final UserId userId;

    public UserNotFoundException(UserId userId) {
        super(String.format("Could not find user with id %s", userId));
        this.userId = userId;
    }

    @ResponseErrorProperty(includeIfNull=true) // <.>
    public String getUserId() {
        return userId.asString();
    }
}
----
<.> Set the `includeIfNull` setting to `true`

The resulting response assuming the passed in `userId` is `null`:

[source,json]
----
{
  "code": "USER_NOT_FOUND",
  "message": "Could not find user with id UserId{id=8c7fb13c-0924-47d4-821a-36f73558c898}",
  "userId": null
}
----

=== Custom JSON response field names

If the `code`, `message`, `fieldErrors` and/or `globalErrors` field names are not to your liking, then you can customize those through the following properties:

[source,properties]
----
error.handling.json-field-names.code=errorCode
error.handling.json-field-names.message=description
error.handling.json-field-names.field-errors=fieldFailures
error.handling.json-field-names.global-errors=classFailures
----

With these settings, a response will look similar to this:

[source,json]
----
{
  "errorCode": "VALIDATION_FAILED",
  "description": "Validation failed for object='exampleRequestBody'. Error count: 4",
  "fieldFailures": [
    {
      "code": "INVALID_SIZE",
      "property": "name",
      "message": "size must be between 10 and 2147483647",
      "rejectedValue": ""
    }
  ],
  "classFailures": [
    {
      "code": "ValidCustomer",
      "message": "UserAlreadyExists"
    }
  ]
}
----

== Properties

|===
|Property |Description|Default

|error.handling.enabled
|Allows to enable or disable the error handling
|true

|error.handling.exception-logging
|Allows to set how the exception should be logged.
One of: `NO_LOGGING`, `MESSAGE_ONLY`,
`WITH_STACKTRACE`.
|MESSAGE_ONLY

|error.handling.default-error-code-strategy
|Determines how an Exception is converted into a `code` in case there is no `@ResponseErrorCode` present on the class.
One of `FULL_QUALIFIED_NAME`, `ALL_CAPS_CONVERSION`.
|`FULL_QUALIFIED_NAME`

|error.handling.http-statuses
|Allows to set the HttpStatus response code to use for the full qualified name of an `Exception`
| `HttpStatus.INTERNAL_SERVER_ERROR` is used for custom exceptions have no specific response status set here.

|error.handling.codes
|Allows to set the code that should be used for the full qualified name of an `Exception` or the name of a validation annotation.
|

|error.handling.messages
|Allows to set the message that should be used for the full qualified name of an `Exception` or the name of a validation annotation.
|

|error.handling.json-field-names.code
|The field name that is used to serialize the `code` to JSON.
|`code`

|error.handling.json-field-names.message
|The field name that is used to serialize the `message` to JSON.
|`message`

|error.handling.json-field-names.fieldErrors
|The field name that is used to serialize the `fieldErrors` to JSON.
|`fieldErrors`

|error.handling.json-field-names.globalErrors
|The field name that is used to serialize the `globalErrors` to JSON.
|`globalErrors`

|===
